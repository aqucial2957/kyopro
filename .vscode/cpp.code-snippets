{
	// Place your kyopro ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	//////////////
	// snippets //
	//////////////

	"all": {
		"prefix": "all",
		"body": "${1:v}.begin(), $1.end()${0:}"
	},

	"cin": {
		"prefix": "cin",
		"body": [
			"${1:int} ${2:n}; cin >> $2;",
			"${0:}"
		]
	},

	"cin2": {
		"prefix": "cin2",
		"body": [
			"${1:int} ${2:n}, ${3:k}; cin >> $2 >> $3;",
			"${0:}"
		]
	},

	"cin3": {
		"prefix": "cin3",
		"body": [
			"${1:int} ${2:a}, ${3:b}, ${4:c}; cin >> $2 >> $3 >> $4;",
			"${0:}"
		]
	},

	"cinp": {
		"prefix": "cinp",
		"body": [
			"vector<pair<${1:int}, ${2:int}>> ${3:v}(${4:n});",
			"for (int i = 0; i < $4; i++) cin >> $3[i].first >> $3[i].second;",
			"${0:}"
		]
	},

	"cinv": {
		"prefix": "cinv",
		"body": [
			"vector<${1:int}> ${2:v}(${3:n});",
			"for (int i = 0; i < $3; i++) cin >> $2[i];",
			"${0:}"
		]
	},

	"cinvv": {
		"prefix": "cinvv",
		"body": [
			"vector<vector<${1:int}>> ${2:v}(${3:h}, vector<$1>(${4:w}));",
			"for (int i = 0; i < $3; i++) {",
			"\tfor (int j = 0; j < $4; j++) {",
			"\t\tcin >> $2[i][j];",
			"\t}",
			"}",
			"${0:}"
		]
	},

	"cout": {
		"prefix": "cout",
		"body": "cout << ${1:ans} << endl;${0:}"
	},

	"coutc": {
		"prefix": "coutc",
		"body": "cout << ((${1:flag}) ? ${2:\"Yes\"} : ${3:\"No\"}) << endl;${0:}"
	},

    "for": {
        "prefix": "for",
        "body": [
            "for (int ${1:i} = ${2:0}; $1 < ${3:n}; $1++) $0"
        ]
	},
	
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${1:i} = ${2:n} - 1; $1 >= ${3:0}; $1--) $0"
        ]
    },

    "rfor": {
        "prefix": "rfor",
        "body": [
            "for (auto& ${1:e} : ${2:v}) {",
            "\t${0:/* code */}",
            "}"
        ],
	},

	"setprecision": {
		"prefix": "sp",
		"body": "fixed << setprecision(15)",
	},
	
    "switch": {
        "prefix": "switch",
        "body": [
			"switch (${1:expression}) {",
			"\tcase $2:",
			"\t\t${0:/* code */}",
			"\t\tbreak;",
            "\tdefault:",
            "\t\tbreak;",
            "}"
        ],
    },

	"template": {
		"prefix": "inc",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"constexpr int inf = 0x3f3f3f3f;",
			"constexpr ll linf = 0x3f3f3f3f3f3f3f3fLL;",
			"",
			"int main()",
			"{",
			"    cin.tie(0);",
			"    ios::sync_with_stdio(false);",
			"",
			"    ${0:/* code */}",
			"    return 0;",
			"}",
			""
		]
	},

	"template (for AtCoder)": {
		"prefix": "inca",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using namespace atcoder;",
			"",
			"using ll = long long;",
			"// using mint = modint1000000007;",
			"// using mint = modint998244353;",
			"// using mint = modint;",
			"",
			"constexpr int inf = 0x3f3f3f3f;",
			"constexpr ll linf = 0x3f3f3f3f3f3f3f3fLL;",
			"",
			"int main()",
			"{",
			"    cin.tie(0);",
			"    ios::sync_with_stdio(false);",
			"",
			"    ${0:/* code */}",
			"    return 0;",
			"}",
			""
		]
	},

	"while": {
        "prefix": "while",
        "body": [
            "while (${1:/* condition */}) {",
            "\t${0:/* code */}",
            "}"
		],
	},
	

	///////////////
	// libraries //
	///////////////

	"binary indexed tree": {
		"prefix": "BIT",
		"body": [
			"template <typename T>",
			"class BIT",
			"{",
			"public:",
			"    BIT(int size, T unity = 0) : bit(++size, unity), _unity(unity) {}",
			"",
			"    // [a, b)の和を計算する",
			"    T sum(int a, int b) { return _sum(b - 1) - _sum(a - 1); }",
			"",
			"    // i番目の要素にxを加算",
			"    void add(int i, T x) {",
			"        for (++i; i < (int)bit.size(); i += i & -i) bit[i] += x;",
			"    }",
			"",
			"private:",
			"    vector<T> bit;",
			"    T _unity;",
			"",
			"    T _sum(int i) {",
			"        T s = _unity;",
			"        for (++i; i > 0; i -= i & -i) s += bit[i];",
			"        return s;",
			"    }",
			"};",
		]
	},

	"combination": {
		"prefix": "comb",
		"body": [
			"class Combination",
			"{",
			"private:",
			"    vector<mint> _fact, _inv_fact;",
			"    ",
			"public:",
			"    Combination(int size) : _fact(size + 1), _inv_fact(size + 1) {",
			"        _fact[0] = 1;",
			"        for (int i = 1; i <= size; i++) _fact[i] = _fact[i-1] * i;",
			"        _inv_fact[size] = _fact[size].inv();",
			"        for (int i = size - 1; i >= 0; i--) _inv_fact[i] = _inv_fact[i+1] * (i+1);",
			"    }",
			"",
			"    mint fact(int k) const {return _fact[k];}",
			"    mint inv_fact(int k) const {return _inv_fact[k];}",
			"",
			"    mint P(int n, int r) {",
			"        if (r < 0 || n < r) return 0;",
			"        else return fact(n) * inv_fact(n - r);",
			"    }",
			"",
			"    mint C(int n, int r) {",
			"        if (r < 0 || n < r) return 0;",
			"        else return fact(n) * inv_fact(r) * inv_fact(n - r);",
			"    }",
			"",
			"    mint H(int n, int r) {",
			"        if (n < 0 || r < 0) return 0;",
			"        else return r == 0 ? 1 : C(n + r - 1, r);",
			"    }",
			"};",	
		]
	},

	"factorize": {
		"prefix": "fact",
		"body": [
			"map<ll, int> factorize(ll n)",
			"{",
			"    map<ll, int> mp;",
			"    for (ll i = 2; i * i <= n; i++) {",
			"        while (n % i == 0) {",
			"            mp[i]++; n /= i;",
			"        }",
			"    }",
			"    if (n != 1) mp[n] = 1;",
			"    return mp;",
			"}",	
		]
	},

	"gcd/lcm": {
		"prefix": "gl",
		"body": [
			"// 最大公約数",
			"#if __cplusplus < 201703L",
			"template <typename M, typename N>",
			"constexpr common_type_t<M, N> gcd(M a, N b) { return (b != 0) ? gcd(b, a % b) : abs(a); }",
			"#endif",
			"template <typename ForwardIt>",
			"constexpr typename iterator_traits<ForwardIt>::value_type",
			"gcd(ForwardIt first, ForwardIt last)",
			"{",
			"    using val_t = typename iterator_traits<ForwardIt>::value_type;",
			"    if (first == last) return static_cast<val_t>(0);",
			"    val_t res = *first;",
			"    while (++first != last) res = gcd(res, *first);",
			"    return res;",
			"}",
			"template <typename T>",
			"constexpr T gcd(initializer_list<T> t) { return gcd(t.begin(), t.end()); }",
			"",
			"// 最小公倍数",
			"#if __cplusplus < 201703L",
			"template <typename M, typename N>",
			"constexpr common_type_t<M, N> lcm(M a, N b) { return (a != 0 && b != 0) ? a / gcd(a, b) * b : 0; }",
			"#endif",
			"template <typename ForwardIt>",
			"constexpr typename iterator_traits<ForwardIt>::value_type",
			"lcm(ForwardIt first, ForwardIt last)",
			"{",
			"    using val_t = typename iterator_traits<ForwardIt>::value_type;",
			"    if (first == last) return static_cast<val_t>(0);",
			"    val_t res = *first;",
			"    while (++first != last) res = lcm(res, *first);",
			"    return res;",
			"}",
			"template <typename T>",
			"constexpr T lcm(initializer_list<T> t) { return lcm(t.begin(), t.end()); }",
		]
	},

	"matrix": {
		"prefix": "mat",
		"body": [
			"template <typename T>",
			"class Matrix",
			"{",
			"public:",
			"    Matrix(int n, int m)",
			"        : m_value(n, vector<T>(m, 0)), m_row(n), m_col(m) {}",
			"    Matrix(initializer_list<initializer_list<T>> init)",
			"        : m_value(init.begin(), init.end()), m_row(init.size()), m_col((*init.begin()).size()) {}",
			"",
			"    int row(void) const { return m_row; }",
			"    int col(void) const { return m_col; }",
			"",
			"    vector<T> &operator[](int i) { return m_value[i]; }",
			"    const vector<T> &operator[](int i) const { return m_value[i]; }",
			"",
			"    // 単位行列E",
			"    static Matrix E(int n)",
			"    {",
			"        Matrix res(n, n);",
			"        for (int i = 0; i < n; i++) res[i][i] = 1;",
			"        return res;",
			"    }",
			"",
			"    Matrix &operator+=(const Matrix &A)",
			"    {",
			"        int n = this->row(), m = this->col();",
			"        assert(n == A.row() && m == A.col());",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < m; j++) {",
			"                (*this)[i][j] += A[i][j];",
			"            }",
			"        } ",
			"        return *this;",
			"    }",
			"",
			"    Matrix &operator-=(const Matrix &A)",
			"    {",
			"        int n = this->row(), m = this->col();",
			"        assert(n == A.row() && m == A.col());",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < m; j++) {",
			"                (*this)[i][j] -= A[i][j];",
			"            }",
			"        } ",
			"        return *this;",
			"    }",
			"",
			"    Matrix &operator*=(const Matrix &A)",
			"    {",
			"        int n = this->row(), m = this->col(), l = A.col();",
			"        assert(m == A.row());",
			"",
			"        Matrix res(n, l);",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < l; j++) {",
			"                for (int k = 0; k < m; k++) {",
			"                    res[i][j] += (*this)[i][k] * A[k][j];",
			"                }",
			"            }",
			"        }",
			"        return *this = move(res);",
			"    }",
			"",
			"    Matrix operator+(const Matrix &A) const { return Matrix(*this) += A; }",
			"    Matrix operator-(const Matrix &A) const { return Matrix(*this) -= A; }",
			"    Matrix operator*(const Matrix &A) const { return Matrix(*this) *= A; }",
			"",
			"    Matrix pow(ll n) const",
			"    {",
			"        Matrix e = *this, res = E(this->row());",
			"        while (n) {",
			"            if (n & 1) res *= e;",
			"            e *= e;",
			"            n >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend ostream &operator<<(ostream &os, const Matrix &A)",
			"    {",
			"        int n = A.row(), m = A.col();",
			"        for (int i = 0; i < n; i++) {",
			"            os << \"[\";",
			"            for (int j = 0; j < m; j++) {",
			"                os << A[i][j];",
			"                if (j < m - 1) os << ", ";",
			"            }",
			"            os << \"]\";",
			"            if (i < n - 1) os << endl;",
			"        }",
			"        return os;",
			"    }",
			"",
			"private:",
			"    vector<vector<T>> m_value;",
			"    size_t m_row;",
			"    size_t m_col;",
			"};",			
		]
	},

	"modint": {
		"prefix": "mint",
		"body": [
			"template <ll mod>",
			"class modint",
			"{",
			"public:",
			"    constexpr modint(ll value = 0) : _value(value >= 0 ? value % mod : (value % mod) + mod) {}",
			"",
			"    constexpr modint operator+() const { return *this; }",
			"    constexpr modint operator-() const { return modint(-_value); }",
			"",
			"    constexpr modint &operator+=(const modint &rhs) {",
			"        if ((_value += rhs._value) >= mod) _value -= mod;",
			"        return *this;",
			"    }",
			"    constexpr modint &operator-=(const modint &rhs) {",
			"        if ((_value += mod - rhs._value) >= mod) _value -= mod;",
			"        return *this;",
			"    }",
			"    constexpr modint &operator*=(const modint &rhs) {",
			"        (_value *= rhs._value) %= mod;",
			"        return *this;",
			"    }",
			"    constexpr modint &operator/=(const modint &rhs) {",
			"        *this *= rhs.inv();",
			"        return *this;",
			"    }",
			"    constexpr modint operator+(const modint &rhs) const { return modint(*this) += rhs; }",
			"    constexpr modint operator-(const modint &rhs) const { return modint(*this) -= rhs; }",
			"    constexpr modint operator*(const modint &rhs) const { return modint(*this) *= rhs; }",
			"    constexpr modint operator/(const modint &rhs) const { return modint(*this) /= rhs; }",
			"",
			"    constexpr modint operator++() { *this += 1; return *this; }",
			"    constexpr modint operator--() { *this -= 1; return *this; }",
			"    constexpr modint operator++(int) { modint tmp = *this; ++*this; return tmp; }",
			"    constexpr modint operator--(int) { modint tmp = *this; --*this; return tmp; }",
			"",
			"    constexpr bool operator==(const modint &rhs) const { return _value == rhs._value; }",
			"    constexpr bool operator!=(const modint &rhs) const { return _value != rhs._value; }",
			"",
			"    constexpr modint inv() const {",
			"        ll a = _value, b = mod, u = 1LL, v = 0LL;",
			"        while (b > 0) {",
			"            ll tmp = a / b;",
			"            a -= tmp * b; swap(a, b);",
			"            u -= tmp * v; swap(u, v);",
			"        }",
			"        return modint(u);",
			"    }",
			"",
			"    constexpr modint pow(ll n) const {",
			"        modint e = *this, res = 1;",
			"        while (n) {",
			"            if (n & 1) res *= e;",
			"            e *= e, n >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend ostream &operator<<(ostream &os, const modint &m) {",
			"        os << m._value;",
			"        return os;",
			"    }",
			"",
			"    friend istream &operator>>(istream &is, modint &m) {",
			"        ll in;",
			"        is >> in;",
			"        m = modint(in);",
			"        return is;",
			"    }",
			"",
			"private:",
			"    ll _value;",
			"};",
			"using mint = modint<1000000007>;",			
		],
	},

	"RLE": {
		"prefix": "rle",
		"body": [
			"vector<pair<char, int>> rle(string s)",
			"{",
			"    vector<pair<char, int>> res;",
			"    char c; int l;",
			"    for (int i = 0; i < (int)s.length(); i++) {",
			"        if (i == 0) {",
			"            c = s[i]; l = 1;",
			"        } else if (s[i] == c) {",
			"            l++;",
			"        } else {",
			"            res.push_back({c, l});",
			"            c = s[i]; l = 1;",
			"        }",
			"    }",
			"    res.push_back({c, l});",
			"    return res;",
			"}",	
		]
	},

	"SegmentTree": {
		"prefix": "seg",
		"body": [
			"template <typename T>",
			"class SegmentTree",
			"{",
			"public:",
			"    SegmentTree(const int n, const T &unit) : _unit(unit)",
			"    {",
			"        _n = 1 << __lg(2 * n - 1);",
			"        _data.resize(2 * _n, unit);",
			"    }",
			"",
			"    SegmentTree(const vector<T> &v, const T &unit) : _unit(unit)",
			"    {",
			"        int n = v.size();",
			"        _n = 1 << __lg(2 * n - 1);",
			"        _data.resize(2 * _n, unit);",
			"",
			"        // 最下段に要素をセット",
			"        for (int i = 0; i < n; i++) this->set(i, v[i]);",
			"        // セグメント木を構築",
			"        this->build();",
			"    }",
			"",
			"    // k 番目の要素を最下段にセット",
			"    void set(int k, const T &x) { _data[k + _n] = x; }",
			"",
			"    // セグメント木を構築",
			"    void build(void)",
			"    {",
			"        for (int i = _n - 1; i > 0; i--) _data[i] = f(_data[2 * i], _data[2 * i + 1]);",
			"    }",
			"",
			"    // k番目の値をxに更新する",
			"    void update(int k, const T &x)",
			"    {",
			"        k += _n; // 葉の節点に変換",
			"        _data[k] = x;",
			"        while (k >>= 1) _data[k] = f(_data[2 * k], _data[2 * k + 1]);",
			"    }",
			"",
			"    // 区間[a, b)に対してクエリ処理した結果を返す",
			"    T query(int a, int b)",
			"    {",
			"        T left = _unit, right = _unit;",
			"        a += _n, b += _n; // 葉の節点に変換",
			"        for (; a < b; a >>= 1, b >>= 1) {",
			"            if (a & 1) left  = f(left, _data[a++]);",
			"            if (b & 1) right = f(_data[--b], right);",
			"        }",
			"        return f(left, right);",
			"    }",
			"",
			"    const T &operator[](size_t k) const { return _data[k + _n]; }",
			"    T &operator[](size_t k) { return _data[k + _n]; }",
			"",
			"private:",
			"    int _n;          // 要素数",
			"    vector<T> _data; // データを格納する配列",
			"    T _unit;        // 単位元",
			"",
			"    // クエリ処理用の関数",
			"    T f(const T &a, const T &b) { return min(a, b); }",
			"};",			
		]
	},

	"UnionFind": {
		"prefix": "uf",
		"body": [
			"class UnionFind",
			"{",
			"public:",
			"    UnionFind(int n = 0) : _data(n, -1), _count(n) {}",
			"",
			"    int find(int x)",
			"    {",
			"        if (_data[x] < 0) return x;",
			"        else return _data[x] = find(_data[x]);",
			"    }",
			"",
			"    bool unite(int x, int y)",
			"    {",
			"        x = find(x), y = find(y);",
			"        if (x == y) return false;",
			"",
			"        if (_data[x] > _data[y]) swap(x, y);",
			"        _data[x] += _data[y];",
			"        _data[y] = x;",
			"        _count--;",
			"        return true;",
			"    }",
			"",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"",
			"    int size(int x) { return -_data[find(x)]; }",
			"",
			"    int count(void) const { return _count; }",
			"",
			"private:",
			"    vector<int> _data;",
			"    int _count;",
			"};",
		]
	},

	"WeightedUnionFind": {
		"prefix": "wuf",
		"body": [
			"template<typename T = int>",
			"class WeightedUnionFind",
			"{",
			"public:",
			"    WeightedUnionFind(int n = 0, T unity = 0) : _data(n, -1), _weight(n, unity), _count(n) {}",
			"",
			"    int find(int x)",
			"    {",
			"        if (_data[x] < 0) return x;",
			"",
			"        int root = find(_data[x]);",
			"        _weight[x] += _weight[_data[x]];",
			"        return _data[x] = root;",
			"    }",
			"",
			"    T weight(int x)",
			"    {",
			"        find(x);",
			"        return _weight[x];",
			"    }",
			"",
			"    bool unite(int x, int y, T w)",
			"    {",
			"        w += weight(x), w -= weight(y);",
			"        x = find(x), y = find(y);",
			"        if (x == y) return false;",
			"",
			"        if (_data[x] > _data[y]) {",
			"            swap(x, y);",
			"            w = -w;",
			"        }",
			"        _data[x] += _data[y];",
			"        _data[y] = x;",
			"        _weight[y] = w;",
			"        _count--;",
			"        return true;",
			"    }",
			"",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"",
			"    T diff(int x, int y) { return weight(y) - weight(x); }",
			"",
			"    int size(int x) { return -_data[find(x)]; }",
			"",
			"    int count(void) const { return _count; }",
			"",
			"private:",
			"    vector<int> _data;",
			"    vector<T>   _weight;",
			"    int _count; ",
			"};",
		]
	}
}